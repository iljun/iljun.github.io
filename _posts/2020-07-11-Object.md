---
layout: post
title: Object 책을 읽고 내용을 정리
---
## 소프트웨어의 목적
    1. 정상작동을 해야한다.
    2. 변경을 위해 존재한다.
    3. 코드를 읽는 사람과 의사소통을 한다.
    
- 의존성
    - 서로간의 의존성이 높아질 경우 하나의 객체가 변경될때 다른곳의 객체도 수없이 변경되어야한다.
- 결합도
    - 객체간의 의존성이 높은경우 결합도가 높다고 표현한다.

```의존성을 낮추고, 결합도를 낮추기 위해서는 서로간의 객체를 자율적인 존재로 만들면 된다.```

- 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는것을 ```캡슐화```라고한다.
    - 객체 내부의 세부적인 사항을 감추는것은 객체를 자율적인 객체로 만들려고 하는것이다.
    - 캡슐화의 목적은 객체를 변경하기 쉬운 객체로 만들기 위함이다.
    - 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출수 있다.
- 객체끼리는 서로의 인터페이스에만 의존하며, 상세 구현은 숨긴다. 
    - 결합도를 낮추고 변경하기 쉬운 코드를 만들기 위해서 지켜야하는 가장 기본적인 설계이다.
- 응집도
    - 밀접하게 연관된 작업만을 수행하고, 연관성이 없는 작업은 다른 객체에게 위임하는 객체를 가르켜 응집도가 높다고한다. 자신의 데이터를 직접 처리하는 자율적인 객체이다.

```객체지향 설계의 핵심은 적절한 객체에 적절한 책임을 할당하는 것이다.```

절차지향의 따라 순서대로 로직을 진행하게 된다면, 
객체들의 의존성이 커지며, 결합도가 높아지고, 응집도가 낮아진다. 그러므로 변화에 탄력적으로 대응할 수 없게된다.

```객체지향의 본질은 class가 아닌 객체이다```

1. 어떠한 class가 존재하는지를 판단하지 말고, 어떠한 객체가 필요한지를 판단해라.
    - 클래스는 공통적인 상태와 행동을 공유하는 객체를 추상화 시킨것이다.
    - 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야한다.

2. 객체를 독립적인 존재가 아닌 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야한다.
    - 객체지향은 서로 상호작용을 하면서 비지니스 로직을 수행한다. 
    - 객체가 협력하는것으로 판단해야 유연하고 확장 가능한 설계가 가능하다.

### 도메인
    소프트웨어는 사용자가 어떤 문제를 해결하기 위해서 만들어진다.
    문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 도메인이라고 부른다.

다른 개발자의 클래스를 사용할때 가장 중요한 것은 클래스의 경계를 구분 짓는 것이다. 
    - 클래스의 경계 즉 외부와 내부를 구분해야 하는 이유는 경계의 명확성이 객체의 자율성을 보장하기 때문이다.

객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 `요청(request)`할 수 있고, 
요청을 받은 객체는 자율적이 방법에 따라 요청을 처리한 후 `응답(response)`한다.

객체와 객체가 상호 작용 할 수 있는 유일한 방법은 `메시지를 전송`하는 것 뿐이며, 
다른 객체에게 요청이 도착할 때 해당 객체는 `메시지를 수신` 했다고 한다.

메시지를 수진한 객체는 자율적으로 메시지를 처리할 방법을 선택하고, 
수신된 메시지를 처리하기 위한 방법은 `method`라고 한다.

`메시지와 메서드의 구분이 가장 중요하다.`

메시지와 메서드의 구분부터 **다형성**의 개념이 출발한다.

template method pattern
    - 부모 클래스의 알고리즘 흐름을 구현하고, 중간에 필요한 처리를 자식 클래스에게 위임하는 패턴이다.

다형성 
    - 객체가 동일한 인터페이스를 가지고 있지만 다르게 동작하는것을 의미한다. 
    - 컴파일 시간 의존성과 런타임 시간 의존성이 다를 수 있다는 기반을 가지고 간다.

`상속은 구현 상속과 인터페이스 상속으로 분류 할 수 있다.`
   - 상속은 구현 상속이 아닌 인터페이스 상속을 위해 사용해야 한다. 
   - 인터페이스 재사용할 목적이 아닌 상태로 상속을 사용하면 변경에 취약한 코드를 낳게된다.

추상화를 이용하면 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현가능하다. 
이 의미는 상위 정책을 표현한다면 기존 구조를 변경하지 않고 새로운 기능을 쉽게 추가하고 확장 가능하다.

`추상화를 적용해야하는 곳은 유연성이 필요한곳이다.`

### 합성(composition)

상속은 코드를 재사용하기 위해 널리 사용되는 방법이다. 
그러나 합성이 조금 더 좋은 방법이다.

상속은 객체지향에서 코드를 재사용하기 위해 널리 사용되는 방법이지만, 
    상속의 단점은 캡슐화를 위반한다는것과, 
    설계를 유연하게 만들지 못한다는 점이다.

하지만 인스턴스 변수를 이용해 관리한다면 변경에 조금더 유연하게 대처할 수 있다.

`합성이란 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 합성이라한다.`

객체지향 패러다임의 핵심은 `역할, 책임, 협력`이다.

객체지향의 본질은 협력하는 객체들의 공동체를 창조하는 것이다.

협력을 구성하기 위해서 적절한 객체를 찾고, 책임을 할당하는 과정이 객체지향 설계의 핵심이다.

객체들이 어플리케이션의 기능을 구현하기 위해서 수행하는 상호작용을 `협력`이라고하며,

객체가 협력에 참여하기 위해 수행하는 로직을 `책임`이라고 부른다.

협력안에서 수행하는 책임들이 모여 객체가 수행하는 `역할`을 구성한다.
   - 객체들간의 요청과 응답이 어플리케이션의 기능을 구현하게 된다.

`책임주도 설계 방법의 과정`
1. 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악
2. 시스템 책임을 더 작은 책임으로 분할
3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당
4. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
5. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

#### 메시지가 객체를 결정한다.

객체에게 책임을 할당하는데 필요한 메시지를 먼저 식별하고 메시지를 처리할 객체를 나중에 선택했다는것이 중요!

메시지가 객체를 선택하게 했다.

1. 객체가 최소한의 인터페이스를 가질 수 있게 된다.
2. 객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다.

`행동이 상태를 결정한다.`

객체에서 중요한것은 상태가 아닌 행동이다!

객체의 행동을 결정하고 나서야 객체가 가질 수 있는 상태를 정의할 수 있고, 그 행동이 바로 객체의 책임이 된다.

`역할`
  - 객체가 협력 안에서 수행하는 책임의 집합을 역할이라고 칭한다.

역할은 다른것으로 교체 할 수 있는 책임의 집합이다.
    - 다른 역할로 언제든지 교체될수 있다.

책임 중심의 설계로 전환하기 위해서는 두 가지 원칙이 필수이다.

1. 데이터보다 행동을 먼저 결정하라
2. 협력이란 문맥 안에서 책임을 결정하라

책임 할당을 위한 `GRASP` 패턴

어떤 책임을 할당해야 할 때 가장 먼저 고민해야 하는 유력한 후보는 바로 도메인 개념이다.

`메시지를 전송할 객체는 무엇을 원하는가?`

`메시지를 수신할 적합한 객체는 누구인가?`

- 객체에게 책임을 할당하는 첫 번째 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는것 이것을 `INFORMATION EXPERT(정보 전문가)` 패턴이라고 부른다.

메시지를 수신했을때 객체가 수행하는 작업의 흐름을 생각해보자. 객체의 내부로 들어가 메시지를 처리하기 위해 필요한 절차와 구현을 고민해보는 단계이다. 이때 스스로 처리할 수 없는 작업이 있다면 외부 객체에게 도움을 요청해야한다.

`LOW COUPLING(낮은 결합도), HIGH COHESION(높은 응집도)패턴` 
- 전체적인 결합도가 낮고 응집도는 높이기 위한 패턴, 객체가 최대한 의존하는걸 낮게 만들어야 한다.

`CREATOR(창조자)패턴`
- 창조자에게 객체 생성 책임을 할당하라.

어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체의 생성을 맡기는 것이다.

객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하는것

이것이 바로 `POLYMORPHISM(다형성)` 패턴이라고 부른다.

변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당

이것이 `PROTECTED VARIATIONS(변경 보호)`패턴이다.

좋은 인터페이스는 `최소한의 인터페이스와 추상적이 인터페이스`라는 조건을 만족해야한다.

최소한의 인터페이스는 꼭 필요한 오퍼레이션만을 인터페이스에 포함한다.

추상적인 인터페이스는 어떻게 수행하는지가 아니라 무엇을 하는지를 표현한다.

퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법

- 디미터법칙
    - 객체 내부의 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위한 법칙
    - 객체 내부의 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다.
- 묻지 말고 시켜라
    - 상태를 묻는 오퍼레이션을 두지 않는것
    - 상태를 묻는 오퍼레이션을 행동을 요청하는 인터페이스로 대체하라.
- 의도를 드러내는 인터페이스
    - 메서드의 이름을 짓는 두 번째 방법은 `어떻게(How)가 아니라 무엇(What)을` 하는지 드러내는 것이다.
    - 메서드의 이름을 무엇을 하는지로 이름을 짓는 패턴을 의도를 드러내는 선택자 라고 부른다.
- 명령-쿼리 분리
    - 질문이 답변을 수정해서는 안된다.
        - 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
        - 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.

객체의 불필요한 정보를 재거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업을 추상화라고 부른다.

가장 일반적인 추상화 방법은 한 번에 다루어야 하는 문제의 크기를 줄이는 것이다. 큰 문제를 해결 가능한 작은 문제로 나누는 작업을 **분해(decomposition)**라고 한다.

현대적 프로그래밍 언어를 특정 짓는 중요한 두 가지 추상화 메커니즘은 `프로시저 추상화(procesure abstraction)`, 
`데이터 추상화(data abstraction)`이다.

프로시저 추상화는 소프트웨어가 무엇을 해야하는지를 추상화 하는것이다.

데이터 추상화는 소프트웨어가 무엇을 알아야 하는지 추상화를 한다.

소프트웨어는 데이터를 이용해 정보를 표현하고, 프로시저를 이용해 데이터를 조작한다.

프로시저 추상화를 중심으로 시스템을 분해하기로 결정했다면 **기능 분해(functional decomposition)**의 길로 들어서는 것이다.

데이터 추상화를 중심으로 시스템을 분해하기로 결정했다면 다시 두 가지 중 하나를 선택해야 한다.

데이터를 중심으로 타입을 추상화하는것과 데이터를 중심으로 프로시저를 추상화 하는 것이다.

데이터르 중심으로 타입을 추상화하는것을 추상 데이터 타입이라고 부르고, 후자를 객체지향이라고 부른다.


## 의존성 관리하기 

잘 설계된 객체지향 어플리케이션은 작고 응집도 높은 객체들로 구성된다.

이렇게 설계된 작은 객체들은 단독으로 수행할 수 있는 작업이 거의 없기 때문에 일반적으로 다른 객체에게 메시지를 전송하며 협력한다.

하지만 과도한 협력은 설계를 곤경에 빠트릴 수 있다. 협력은 객체가 다른 객체에 대해서 알고있는것을 강요한다.

객체가 협력하려면 서로가 수신할 메시지에 대해서 알고 있어야하며, 이런 것들이 의존성을 낳는다.

협력을 위해서는 의존성이 필요하지만 과도한 의존성을 없애고, 변경을 방해하는 의존성을 제거하여야 한다.

`의존성 전이(transitive dependency)`

객체가 하나의 객체에 의존하고 있을때 의존하는 객체가 의존하고 있는 다른 객체에도 의존하고 있다는 의미이다.

의존성은 함께 변경될 수 있는 가능성을 의미하는 것이기 땜누에 모든 경우에 의존성이 전염되는 것은 아니다.

의존성이 실제 전이될지 여부는 변경의 방향과 캠슐화의 정도에 따라 달라진다.

내부 구현을 효과적으로 캡슐화하고 있다면 의존성이 전이되지 않을것이다.

의존성은 전이될 수 있기 때문에 `직접 의존성(direct dependency)`, `간접 의존성(indirect dependency)`으로 나눈다.

직접 의존성은 다른 요소의 직접 의존하는 경우를 의미하며, 간접 의존성은 직접적인 관계는 존재하지 않지만 의존성 전의에 의해 영향이 전파되는 경우를 가리킨다.

의존성과 관련해서 다루어야하는 다른 주제는 `런타임 의존성(run-time dependency)`, `컴파일 타임 의존성(compile-time dependency)`의 차이이다.

런타임은 어플리케이션이 실행되는 시점을 의미하며, 컴파일 타임은 작선된 코드의 컴파일 시점을 가리키지만, 문맥에 따라서 코드 자체를 가리키기도 한다.

객체지향 어플리케이션에서 런타임의 주인공은 객체이다. 런타임 의존성이 다루는 주제는 객체사이의 의존성이다.

반면 코드 관점에서의 주인공은 클래스이다. 따라서 컴파일 의존성이 다루는 주제는 클래스 사이의 의존성이다.

이 두가지 관점에서 가장 중요한것은 런타임 시점과 컴파일 시점의 의존성이 다를수 있다는 것이다.

클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해서는 협력할 인스턴스의 구체적인 클래스를 알아서는 안된다. 실제로 협력한 객체가 어떤것인지는 런타임에 해결하여한다.

만약 동일한 인터페이스를 가진 객체 2개 존재한다고 했을때 하나의 객체에서 이 2개의 객체에 의존성을 가지고 있는것은 좋은 방법이아니다. 이런 문제를 해결하기 위해서 2개의 인터페이스를 가진 객체를 숨기고, 인터페이스에만 의존하게해 런타임에 객체를 선택해 작동하게 만들어야 한다.

클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알면 안되게 코딩을 해야한다. 그 클래스의 구제적인 인스턴스를 안다면 강하게 결합되기 때문이다.

이렇기 때문에 컴파일 타임의 의존성과 런타임의 의존성이 달라야한다는 사실을 이해했을 것이다.

`context 독립성`

구체적인 클래스에 의존하는것은 클래스의 인스턴스가 어떤 문맥에서 사용될지 구제적으로 명시하는 것이다.

클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서는 사용하기가 더 어려워진다.

클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이루어져 있다면 다른 context에서 사용하기 더욱 편리하다. 이를 context 독립성이라고 한다.

설계가 유연해지기 위해서는 가능한 자신이 실행될 context에 대한 구체적인 정보를 최대한 적게 알아야한다.

context에 대한 정보를 적게 알면 알수록 다른 context에서 재사용이 편리해진다.

`의존성 해결하기`

컴파일 타임의 의존성을 context에 맞게 적절한 런타임 의존성으로 교체하는것을 의존성 해결이라고 부른다.

의존성을 해결하기 위해서는 일반적으로 3가지 방법을 사용한다.

- 객체를 생성하는 시점에 생성자를 통해 의존성 해결
- 객체 생성 후 setter 메서드를 통해 의존성 해결
- 메서드 실행 시 인자를 이용해 의존성 해결

setter 메서드를 이용하는 경우는 객체를 생성한 이후에 의존하고 있는 대상을 변경 할 수 있는 가능성이 필요할 경우 유용하다.

하지만 객체가 생성된 후 의존 대상을 주입해야하기 때문에 안전하지 않다는 단점이 존재한다.

가장 좋은 방식은 constructor 방식과 setter 방식을 혼합하는 것이다.

바람직한 의존성은 재상용성과 관련이 있다. 의존성을 100%없앨수는 없기때문에 의존성때문에 다른 환경에서 클래스를 재사용할수 없다면 그 의존성은 바람직하지 못한것이다. 

context에 독립적인 의존성은 바람직한 의존성이며, 특정한 context에 강하게 결합된 의존성은 바람직하지 못하다.

두 요소 사이의 의존성이 바람직할때는 `느슨한 결합도(loose coupling)` 또는 `약한 결합도(weak coupling)` 

의존성이 바람직 하지 못할때는 `단단한 결합도(tight coupling)` 또는 `강한 결합도(strong coupling)`을 가진다고 한다.

의존성의 대상을 생성자의 인자로 전달받는 방법과 생성자 내부에서 직접 생성하는 방법 사이의 가장 큰 차이점은 퍼블릭 인터페이스를 통해 의존성을 노출하느 것이다.

생성자의 인자로 전달받는 방법은 의존성이 명시적으로 퍼블릭 인터페이스에 노출된다. 이러한 경우를 `명시적인 의존성(explicit dependency)`라고 부른다.

반면 생성자 내부에서 직접 객체를 생성하는 방식은 의존한다는 사실을 감춘다.

의존성이 퍼블릭 인터페이스에 표현되지 않는다. 이를 숨겨진 `의존성(hidden dependency)`라고 부른다.

의존성이 명시적이지 않으면, 의존성을 파악하기 위해서 내부 구현을 직접 살펴봐야 하며, 다른 context에서 재사용하려면 내부 구현을 직접 변경해야한다.

`new Keyword`

new 키워드를 이용해 객체를 생성하지만, 잘못 사용하면 결합도가 극단적으로 높아진다.

- new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야한다.
    - 클라이언트 추상화가 아닌 구체 클래스에 의존할 수 밖에 없기 때문에 결합도가 높아진다.
- 구체 클래스뿐만 아니라 생성하는 인자를 알아야한다.

해결방법은 인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리하는 것이다.

의존성이 있는 객체 내부에서 직접 객체를 생성하지 말고, 객체가 생성될때 constructor 또는 setter method를 통해 주입받는것이다.

new Keyword가 언제나 잘못된 것은 아니다.

표준 클래스에 대한 의존성은 나쁘지 않다.

ArrayList처럼 표준 클래스의 수정 여부는 0에 가깝다. 이러한 경우에는 직접 new를 사용해 생성하더라도 문제가 되지 않는다.

`유연한 설계`

확장 가능하고 변화에 유연하게 대응할수 있는 원칙

`개방-폐쇄 원칙(open-closed principle)`
- 클래스, 모듈, 함수는 확장에 열려있어야하며, 수정에 대해서는 닫혀있어야한다.

`확장에 대해 열려있다.`
- 요구사항이 변경될때 이 변경에 맞게 새로운 동작을 추가해서 어플리케이션의 기능을 확장

`수정에 대해 닫혀있다`
- 기존의 코드를 수정하지 않고 어플리케이션의 동작을 추가하거나 변경 할 수 있다.

`컴파일 타임 의존성을 고정시키고 런타임 의존성을 변경하라`

- 컴파일 타임의 의존성을 수정하지 않고 런타임 의존성을 쉽게 변경이 가능하도록 수정하여라

개방-폐쇠 원칙의 핵심은 추상화에 의존하는 것이다.

`생성 사용 분리 `

new keyword를 이용해 객체 내부에서 의존성을 생성할 경우 한곳에 강하게 결합되고 만다. 

한곳에 강하게 결합된다면 개방-폐쇄의 원칙에 위반하게 된다.

객체의 생성과 사용은 분리되어야한다. 유연하고 재사용 가능한 설계를 위해서는

객체의 생성과 사용을 분리하는 패턴이 바로 factory이다.

시스템을 객체로 분리하는 방법은 2가지이다. 

`표현적 분해(representational decomposition)`, `행위적 분해(behavioral decomposition)`이 있다.

표현적 분해는 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해하는것 

표현적 분해는 도메인 모델에 담겨 있는 개념과 관계를 따르며 도메인과 소프트웨어 사이의 표현적 차이를 최소화하는것을 목표로한다. → 객체지향 설계를 위한 가장 기존적인 접근법이다.

모든 책임을 도메인 객체에게 할당한다면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 심각한 문제점에 봉착하게 될 가능성이 높아진다. 이런 문제점을 해결하기 위해서 편의를 위해 임의로 만들어낸 가공의 객체에게 책임을 할당해 문제를 해결해야한다. 이러한 패턴을 순수한 가공물(PURE FABRICATION)이다.

어떤 행동을 추가하려고 하는데 이 행동을 책임질 도메인 개념이 없다면 PURE FABRICATION을 추가하고 이 객체에게 책임을 할당하라. PURE FABRICATION은 행위적 분해에 의해 성성되는 것이 일반적이다.

설계자로써의 역할은 도메인 추상화를 기반으로 어플리케이션의 로직을 설계함과 동시에 품질의 측면에서 균형을 맞추는데 필요한 객체들을 창조하는 것이다.

`의존성 주입`

생성과 사용을 분리하게 된다면 객체에는 오로지 인스턴스를 사용하는 책임만 남게된다.

이것은 외부에서 객체에게 인스턴스를 전달해야한다는것을 의미한다.

외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해 의존성을 해결하는 방법을 `의존성 주입(dependency Injection)`이라고 한다.

`SERVICE LOCATOR 패턴`

의존성에 관련된 객체를 보관하는 일종의 저장소이다.

객체가 직접 SERVICE LOCATOR에게 의존성을 요청하는 패턴이다.

하지만 SERVICE LOCATOR의 가장 큰 문제점은 의존성을 숨기는것이 가장 큰 단점이다.

SERVICE LOCATOR 패턴은 의존성을 주입하는 프래임워크를 사용하지 못하거나 깊은 호출 계층에서 동일한 객체를 계속 전달해야 할때 사용하는 패턴이다.

`의존성 역전 원칙 (dependency Inversion Principle)`

상위 수준의 클래스는 어떠 식으로든 하위 수준의 클래스에 의존해서는 안된다.

추상화를 이용하면 하위 클래스가 변경되어도 상위 클래스는 영향을 받지 않는다. 

또한 상위 클래스를 재사용하려 해도 하위 클래스에 영향을 받지 않고 재사용이 가능하다.

상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안되며, 추상화에 의존해야한다.

추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야 한다.

의존성 역전 원칙은 의존성의 방향뿐만 아니라 인퍼테이스의 소유권에도 적용된다. 

`SEPARATED INTERFACE 패턴 `

객체에서 의존하고 있는 의존성은 하나의 패키지에 위치시켜라.

의존성이 하나의 패키지 또는 모듈의 포함되어 있지 않다면 다른 context의 재사용시 컴파일 오류가 발생할 확률이 있다. 

또한 패키지를 분리한다면 불필요한 클래스의 배포가 필요 없게 된다.

`상속과 코드 재사용`

객체지향의 코드 재사용 방법은 새로운 코드를 추가하는 것이다.

객체지향의 코드는 클래스 안에 작성되기 때문에 객체지향에서 클래스를 재사용하는 방법은 새로운 클래스를 추가하는 것이다.

재사용의 관점에서 상속이란 클래스 안에 정의된 인스턴스 변수와 메서드를 자동으로 새로운 클래스에 추가하는 구현 기법이다.

상속이외로 객체지향에서 코드를 재사용하는 방법에는 `합성`이 있다. 바로 새로운 클래스의 인스턴스 안에 기존 클래스의 인스턴스를 포함시키는 방법이다.

`DRY(Don't Repeat Yourself) 원칙`

중복 코드는 변경을 방해한다.

중복 코드 여부를 판단하는 기준은 변경이다. 요구 사항이 변경되었을때 두 코드를 함께 수정해야 한다면 이 코드는 중복이다.

함께 수정할 필요가 없다면 중복이 아니다.

DRY 원칙은 중복 코드를 생성하지 말라는 원칙이다.

DRY 원칙은 `Once and Only one 원칙` 또는 `Single-Point Control`이라고 한다.

코드를 재사용하는 방법 중 상속의 단점은 부모 class와 자식 class의 결합도를 높이게 된다.

부모 class의 코드를 재사용하기 위해서 자식 class에서 `super method`를 사용한다면 결합도가 정말 높아지게 된다.

그렇기 때문에 super 호출을 제거하고 결합도를 낮출수 있는 방법을 찾아야 한다.

결합도가 높게되면 자식 클래스는 부모 클래스의 수정사항에 항상 엮이게 된다.

이러한 현상을 `취약한 기반 클래스 문제(Fragile Base Class Problem, Brittle Base Class Problem)`이라고 한다.

`불필요한 인터페이스 상속 문제`

불필요한 인터페이스 상속이란 상속을 받으면 불필요한 인터페이스와 구현을 모두 상속받기 때문에 class의 규칙이 깨어질 수 있다.

부모 클래스의 메서드가 자식 클래스의 내부 구조에 대해 규칙을 깨트릴 수 있다.

`메서드 오버라이딩의 오작용 문제`

자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.

`부모 클래스와 자식 클래스의 동시 수정 문제`

자식 클래스가 부모 클래스의 메서드를 오버라이딩하거나 불필요한 인터페이스를 상속 받지 않아도, 

부모 클래스가 수정될 때 자식 클래스의 메서드를 동시에 수정할 수도 있다.

`상속의 문제점을 제거해보자`

`추상화에 의존하자`

부모 클래스와 자식 클래스 모두 추상화에 의존해야한다.

중복 코드를 제거하기 위해서 상속을 도입할 때의 두가지 원칙 
- 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라.
  - 메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있다.
- 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 메서드를 상위로 올려라
  - 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는것이 재사용성과 응집도 측면에서 더 좋은 결과를 얻을 수 있다.
  
`차이를 메서드로 추출하라`

두 클래스에서 차이점이 존재하는 부분을 메서드로 추출하고, 동일한 코드를 부모 클래스로 올려야 한다.

이제 추상화된 부모 클래스에 중복 코드를 추가한다.

자식 클래스들 사이의 공통점을 부모 클래스로 이전하면서 상속 계층을 이용하면서 상속의 단점을 상쇄시킬수 있다.

`합성과 유연한 설계`

합성은 상속과 더불아 객체지향에서 코드 재사용으로 많이 사용되는 기법이다.

합성은 재사용하려는 객체를 포함하여 그 객체의 코드를 재사용하는 기법이며, `has-a` 관계이다.

합성은 상속과는 다르게 내부 구현에 의존하지 않으며 퍼블릭 인터페이스에 의존하기 때문에 객체 내부의 구조가 변경되어도 영향을 최소화 할 수 있다는 장점이 있다.

상속을 사용하다보면 새로운 요구사항이 추가되었을때 과도한 class를 추가해야 하는 일이 발생할 수 있다.

이러한 문제점을 `클래스 폭팔`이라고 부르며, 합성을 사용하면 새로운 요구사항이 추가되었을때 클래스 하나만 추가하면 동작을 하게 된다.

`믹스인`

객체를 생성할 때 코드 일부분을 클래스 안에 섞어 넣어 재사용하는 기법이다. 

상속을 코드의 재사용 목적으로 사용하면 변경이 어려우며, 유연하지 못한 구조를 가지게 된다.

상속의 목적은 코드의 재사용이 아닌 타입 계층을 구조화하기 위함이다.

상속을 사용하려 할때 코드의 재사용보다는 클라이언트의 관점에서 인스턴스들을 동일한 그룹으로 묶기 위해 사용하는지를 먼저 생각해봐라 

`다형성(Polymorphism)`

하나의 추상 인터페이스에 대해 코드를 작성하고 이 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력 

`강제 다형성` 

언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방법 

`매개변수 다형성`

제넥릭 프로그래밍과 관련이 높다.

클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하느 시점에 구체적인 타입으로 지정하는 방식 

`포함 다형성, 서브타입(Subtype) 다형성`

메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력 

객체지향에서 가장 널리 사용되는 다형성의 방법이다.

`상속의 양면성`

객체지향의 패러다임의 근간은 데이터와 행동을 객체라고 불리는 하나의 실행 단위 안으로 통합하는 것이다. 

상속을 이용하면 부모 클래스의 데이터와 행동을 자식클래스가 모두 포함하게 된다. 

하지만 상속의 목적은 다형성을 가능하게 하는 타입 계층을 구축하기 위한 것이다.

상속의 메커니즘을 이해하기 위한 개념 
- 업캐스팅
- 동적 메서드 탐색 
- 동적 바인딩 
- self 참조 
- super 참조 

부모 클래스에 정의된 메서드가 자식 클래스에 포함될지는 언어의 종류에 따라 다르지만, 공통적으로 퍼블릭 메서드는 자식 클래스의 퍼블릭 메서드 인터페이스에 포함된다.

하지만 실제로 코드를 복사하거나 합치는 작업은 이루어지지 않는다.

런타임에 자식 클래스에 정의되지 않은 메서드가 있을 경우 부모 클래스 안에서 탐색하기 때문이다. 

`업캐스팅`
- 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는것이 가능하다.

`동적 바인딩`
- 변수의 타입이 아닌 메시지를 수신하는 객체에 따라 실행되는 메서드가 달라지는것을 동적 바인딩이라고 한다.

`self 참조`
- 객체가 메시지를 수신 받으면 컴파일러는 self 참조 변수를 임시로 생성한후 메시지를 수신한 객체를 가리키도록 설정한다.
- 이 self 참조는 자신부터 부모로 변경되며 메서드를 탐색하고 메서드를 정상적으로 실행한다면 자동으로 사라진다.

`서브클래싱과 서브타이핑`

개념 관점의 타입 
- 개념 관점의 타입은 우리가 인지하는 세상의 사물의 종류이다. (객체들에게 적용하는 개념이나 아이디어)

프로그래밍 언어 관점의 타입 
- 연속적인 비트와 제약을 부여하기 위해 사용된다.

프로그래밍 언어에서 타입의 목적은 2가지이다.
- 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의
- 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공 

객체지향 패러다임 관점의 타입 
- 공통의 특징을 공유하는 대상들의 분류 
- 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합이다. 

`객체지향 프로그래밍에서 타입을 정의하는것은 객체의 퍼블릭 인터페이스를 정의하는 것과 동일하다`

`타입 계층`

타입 계층을 구성하면서 더 일반적인 타입을 슈퍼타입(supertype), 더 특수한 타입을 서브타입(subtype)이라고 부른다.

상속을 사용해야하는 시기 
- 상속 관계가 is-a 관계를 모델링 하는가?
- 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?

행동 호환성 
타입을 is-a 관계를 통해 묶고 싶은경우 두 타입의 행동이 호환될 경우만 묶어야한다.

여기서 호환된다는 의미는 클라이언트 관점에서 봐야한다.

클라이언트가 두 타입이 동일하게 행동한다고 기대한다면 하나의 타입으로 묶을 수 있다.

`subclassing`
- 다른 클래스의 코드를 재사용할 목적으로 상속을 사용한 경우 
- 자식 클래스와 부모 클래스의 행동이 호환되지 않기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대채할 수 없다.
- 구현 상속(implementation inheritance), 클래스 상속(class inheritance)라고도 불린다.

`subtyping`
- 타입 계층을 구성하기 위해 상속을 사용하는 경우를 나타낸다.
- 자식 클래스와 부모 클래스의 행동이 호환된다.
- 인터페이스 상속(interface inheritance)라고 불린다.

`리스코프 치환 원칙`

서브타입은 그것의 기반 타입에 대해 대체 가능해야한다.

클라이언트는 차이점을 인식하지 못한채 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다.

`계약에 의한 설계와 서브타이핑`

클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현하는것 

- 클라이언트가 정상적으로 메서드를 실행하기 위한 조건을 사전조건
- 메서드가 실행 된 후 서버가 클라이언트에게 보장해야 하는 사후조건 
- 메서드 실행 전과 후에 인스턴스가 만족시켜야 하는 클래스 불변식 

계약에 의한 설계와 서브타이핑을 설명하는 이유는 계약을 잘 못 설계할 경우 서브타이핑의 원칙이 깨질수 있기 때문이다.

- 서브타입에 더 강력한 사전조건을 정의 할 수 없다.
- 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.
- 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.
- 서브타입에 더 약한 사후조건을 정의할 수 없다.

`일관성 있는 협력`

재사용을 위해서는 객체들의 협력을 일관성 있게 만들어야 한다.

일관성 있는 설계는 비용을 감소시키며, 코드를 이해하기도 쉬워진다.

유사한 기능을 서로 각기다른 방식으로 구현한다면, 새로운 기능을 추가할때 이전 코드들을 모두 파악해야하며, 새로운 방식을 선택하게 되어 유지보수가 힘들어 진다.

일관성있는 설계를 위해서는 다양한 설계 경험이 필요하다.

다른 방법으로는 디자인 패턴의 적용이다.

일관성있는 설계를 위한 기본 지침
- 변하는 개념을 변하지 않는 개념으로부터 분리하라.
- 변하는 개념을 캡슐화하라.

변하지 않는 개념과 변하는 개념을 분리하여, 변하는 개념이 변경되어도 변하지 않는 개념에는 영향도가 없도록 해야한다.
`ex) 가장 쉽게 if문이 변하는 개념일 확률이 크다. if문을 작은 클래스의 단위로 분리해보자`

커다란 클래스를 작은 클래스로 나눌때 어떤 기준으로 나눈것이 좋을까?

변경의 이유와 주기이다. 클래스는 명확하게 하나의 이유만으로 변경되어야 하며, 클래스 안의 코드는 모두 함께 변경되어야 한다.(단일 책임의 원칙)

커다란 클래스를 작은 클래스로 나누면서 추상클래스를 부모 삼아 계층구조를 구축할 수 있다.
이게 바로 변하는 개념을 캡슐화 한것이다.

캡슐화를 통해 결합도를 낮추고, 의존성을 높이는 것이다.

일관성 있는 협력을 위해서는 패턴을 찾는것이 중요하다.

패턴을 찾아 변하지 않는것과 변하는것을 구분해 분리하는것이 탄탄한 설계를 만드는데 중요한 역할을 한다.