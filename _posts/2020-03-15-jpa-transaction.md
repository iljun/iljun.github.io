---
layout: post
title: JPA Transaction 2
---

# ACID
Transaction은 4가지 상태를 보장해야한다.

- Atomicity 원자성
    - 트랜잭션 내부에서 실행한 작업은 모두 성공하거나, 모두 실패해야한다.
- Consistency 일관성
    - 모든 트랜잭션은 일관성 있는 DB 상태를 유지해야한다. (DB의 무결성 제약 조건을 모두 만족해야한다.)
- Isolation 격리성
    - 동시에 실행되는 Transaction끼리는 영향을 미치면 안된다.
    - 서로 다른 트랜잭션이 같은 Row에 접근하여 데이터를 수정하면 안된다.
- Durability 지속성
    - Transaction을 성공적으로 끝내면 그 결과는 항상 기록이 되어야하며, 중간에 시스템 문제가 발생해도 복구가 가능해야한다.
    
Transaction에서 가장 중욯나 부분이 바로 격리성이다.

Transaction 끼리 격리성을 보장하려면 차례대로 실행해야한다. 그렇기 떄문에 성능에 치명적일 수 있다.

이런 문제를 해결하기 위해 Transation의 격리 수준을 4가지로 나누는데,

- READ UNCOMMITTED
- READ COMMITTED
- REPEATABLE READ
= SERIALIZABLE

### READ UNCOMMITTED
아직 커밋되지 않은 데이터를 읽을 수 있는 수준이다.

DIRTY READ라고도 하는데, 아직 커밋되지 않은 데이터를 읽을 수 있기 때문에 데이터 정합성이 언제든지 꺠질 수 있다.

DIRTY READ를 허용하는 격리 수준이 READ UNCOMMITTED이다.

### READ COMMITTED
커밋한 데이터만 읽기가 가능하다.

DIRTY READ가 방지되는 격리 단계이다.

하지만 NON-REPEATABLE READ는 발생할 수 있다.

NON_REPEATABLE READ란 하나의 트랜잭션 내부에서 언제나 동일한 데이터를 읽을 수 없는 문제이다.

### REPEATABLE READ
한 번 조회한 데이터를 반복해서 조회 할 수 있는 단계이다.

하지만 PHANTOM READ는 발생이 가능하다.

PHANTOM READ란 이전에 존재하던 데이터는 동일하지만 추가되는 데이터가 존재할 수 있는 문제점이다.

### SERIALIZABLE
가장 엄격한 트랜잭션 격리수준이며, 앞에 얘기한 모든 문제점을 막는 격리 단계이다.

하지만 동시성 처리에있어서 성능이 급격히 떨어진다.

`어플리케이션의 대부분은 동시성 처리가 중요하기 때문에 READ COMMITTED를 많이 사용한다.
하지만 Transaction의 중요도에 따라 격리 단계를 적절히 선택해야한다.`

## 낙관적 락과 비관적 락 
JPA는 대부분 트랜잭션 격리 수준을 READ COMMITTED 정도로 가정한다.

일부 로직에 더 높은 격리 수준이 필요하면 낙관적 락과 비관적 락을 사용해야한다.

- 낙관적 락 
    - 트랜잭션 대부분은 충돌이 발생하지 않는다라는 가정을 하는 방법이다.
    - DB의 락이 아니라 JPA가 제공하는 버전 관리 기능을 사용하는 방법이다.
    - 트랜잭션을 커밋하기 전에는 충돌을 알 수 있는 방법이 없다.
- 비관적 락 
    - 트랜잭션이 충돌을 발생한다고 가정하는 방법이다.
    - 여기서는 데이터베이스의 락기능을 이용한다.
    - 대표적으로는 `select for update` 구문을 이용한다.
    
또 다른 문제로는 데이터베이스의 트랜잭션 범위를 넘어서는 경우도 존재한다.

공통으로 수정이 가능한 데이터를 약간의 차이로 수정하게 되면 먼저 수정한 데이터는 찾을 수 없게된다.

이 문제를 두 번의 갱신 분실 문제라고 한다.

이 두번의 갱신 분실 문제는 Transaction만으로는 해결할 수 없다.

이 문제점의 해결 방식은 3가지이다.

- 마지막 커밋만 인정
- 최초 커밋만 인정
- 충돌하는 갱신 내용 병합 

기본으로는 마지막 커밋만 인정하기가 사용되는데, 상황에 따라 다른 방법이 사용되기도 한다.

### @Version
낙관적 락을 사용하기 위해서는 `@Version`을 사용해야한다.

이 어노테이션의 역할은 엔티티가 수정될떄마다 자동으로 버전이 하나씩 증가하며, 조회 시점과 수정 시점의 버전이 다르면 예외가 발생한다.

이 문제는 최초 커밋만 인정하기가 녹아든 락 방법이다.

하지만 이 어노테이션은 벌그 연산에는 동작하지 않는다.

벌크 연산에는 버전 필드를 강제로 증가시켜야한다.

### 낙관적 락의 option
- NONE
    - @Version이 적용된 Entity가 존재하면 낙관적 락이 적용이 된다.
    - 조회 시점부터 수정 시점까지 Transaction을 보장하며, 수정할때 version을 체크해 Exception을 발생시킨다.
- OPTIMISTIC
    - @Version이 적용된 Entity를 조회때부터 버전을 체크한다.
    - 트랜잭션이 끝나기 전까지 다른 트랜잭션에 의해 변경되지 않음을 보장한다.
- OPTIMISTIC_FORCE_INCREMENT
    - 낙관적 락을 사용하면서 버전 정보를 강제로 증가시킨다.
 
### 비관적 락의 option
- PESSIMITIC_WRITE
    - 일반적인 option이다.
    - DB의 write row Lock을 걸어버린다.
    - select for update 구문 이용
- PERSSIMISTIC_READ
    - 반복적인 읽기가 필요할때 사용한다.
    - 데이터는 수정하지 않아야 한다.
- PESSIMISTIC_FORCE_INCREMENT
    - 비관적 락 중 유일하게 버전정보를 사용하며, 강제로 버전정보를 증가시킨다.
     

